# 基于 Redux 的登录状态管理

1. 注册 `userInfoSlice` 管理登录信息

   ```typescript
   /**
    * @Author: bin
    * @Date: 2024-05-29 22:12:59
    * @LastEditors: bin
    * @LastEditTime: 2025-12-16 16:38:11
    */
   import { createSlice, type PayloadAction } from '@reduxjs/toolkit'
   import type { UserInfo } from '../types/userSlice'
   import LocalStorageUtil from '@/utils/storageUtils/LocalStorageUtil'
   
   const defaultUserInfo: UserInfo = {
       token: '',
   }
   const isNeedEncrypt = import.meta.env.MODE === 'production'
   // 获取缓存的 userInfo
   const storageUserInfo = LocalStorageUtil.getItem<UserInfo>('user_info', defaultUserInfo, true, isNeedEncrypt)
   
   export const userInfoSlice = createSlice({
       // 用来自动生成 action 中的 type
       name: 'userInfo',
       initialState: {
           userInfo: storageUserInfo,
       },
       reducers: {
           saveUserInfo: (state, action: PayloadAction<UserInfo>) => {
               state.userInfo.token = action.payload.token
               LocalStorageUtil.setItem('user_info', action.payload)
           },
           removeUserInfo: (state) => {
               state.userInfo.token = ''
               LocalStorageUtil.setItem('user_info', defaultUserInfo)
           },
       },
   })
   
   export const {
       saveUserInfo, removeUserInfo,
   } = userInfoSlice.actions
   
   export default userInfoSlice.reducer
   
   ```

2. 注册 `useAuth` hooks，供 React 函数组件 使用。React 函数组件中所有与登录相关的修改 `userInfoSlice` 的操作，只能通过该 hooks 间接修改

   ```typescript
   import { useDispatch, useSelector } from 'react-redux'
   
   import { saveUserInfo, removeUserInfo } from '@/store/slice/userInfoSlice'
   import { type RootState, type AppDispatch } from '@/store/store'
   import type { UserInfo } from '@/store/types'
   
   /**
    * @description 登录状态管理 hooks
    * 结合 redux 做登录状态管理
    * React 函数组件中所有与登录相关的修改 userInfoSlice 的操作，只能通过该 hooks 间接修改
    */
   export default function useAuth() {
   
       const dispatch = useDispatch<AppDispatch>()
   
       const userInfo = useSelector((state: RootState) => state.userInfo.userInfo)
   
       return {
           userInfo,
           isLogin: !!userInfo.token,
           login: (userInfo: UserInfo) => dispatch(saveUserInfo(userInfo)),
           logout: () => dispatch(removeUserInfo()),
       }
   }
   
   ```

   ```tsx
   import useAuth from '@/hooks/auth/useAuth'
   
   const App: React.FC = () => {
       const { isLogin, login } = useAuth()
       
       return (<></>)
   }
   ```

3. 注册 `auth.store.ts` 供非 React 函数组件调用

   ```typescript
   import store from '@/store/store'
   import { saveUserInfo, removeUserInfo } from '@/store/slice/userInfoSlice'
   import type { UserInfo } from '@/store/types'
   
   /**
    * @description 非 React 场景解耦
    * auth.store.ts 暴露 userInfoSlice 的状态、方法，供非 React 函数组件调用，比如路由守卫 Loader、axios 公共请求方法等
    */
   
   // 获取 userInfoSlice 状态
   export const getAuthState = () => {
       const state = store.getState()
       const userInfo = state.userInfo.userInfo
   
       return {
           userInfo,
           isLogin: !!userInfo.token,
       }
   }
   
   // 登录
   export const login = (userInfo: UserInfo) => {
       store.dispatch(saveUserInfo(userInfo))
   }
   
   // 登出
   export const logout = () => {
       store.dispatch(removeUserInfo())
   }
   
   export default {
       getAuthState,
       login,
       logout,
   }
   
   ```

4. `React Router` 路由守卫，详情请看 [router/index.tsx](../React/ReactRouter/DataRouters_V6.4+封装.md "router/index.tsx")

   ```typescript
   /**
    * @description 创建公共 loader 函数
    * @param route 路由配置对象
    * @returns { LoaderFunction }
    */
   const createPublicLoader = (route: RouteConfig): LoaderFunction => (loaderFunctionArgs: LoaderFunctionArgs<any>) => {
       // 登录路由守卫
       const { isLogin } = authStore.getAuthState()
       if (!isLogin && route.meta?.auth) {
           const url = new URL(loaderFunctionArgs.request.url)
           const redirectTo = url.pathname + url.search
           // 跳转到登录页面，并携带当前页面链接
           throw redirect(`/login?redirect=${encodeURIComponent(redirectTo)}`)
       }
       document.title = (route.meta?.title as string) || 'react'
       // 功能正常返回 null
       return null
   }
   
   ```

   