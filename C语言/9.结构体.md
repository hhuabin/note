#　声明结构体类型

| 写法                                     | 是否有类型名            | 是否可简写         | 是否常用  |
| ---------------------------------------- | ----------------------- | ------------------ | --------- |
| struct Person {...};                     | 有类型名`struct Person` | 用 `struct Person` | ✔ 常用    |
| struct {...} p;                          | 无，匿名结构体          | 无法重复使用       | ❌不常用   |
| typedef struct {...} Person;             | 有别名`Person `         | 最简单             | ⭐ 最常用  |
| **typedef struct Person {...} Person ;** | 有类型名、有别名都有    | 最专业             | ⭐⭐ 最推荐 |

1. `struct Person {...};`

   只定义结构体类型，不创建变量

   ```c
   struct Person {
       char name[20];
       int age;
   };
   
   // 需要使用 struct Person 定义变量
   struct Person p;
   ```

   定义了结构体类型 `struct Person`

   ```c
   struct Person {
       char name[20];
       int age;
   } p1, p2;
   ```

   顺便声明两个变量 `p1, p2`

3. `struct {...} p;`

   **匿名结构体** + 直接定义变量（不再有类型名）

   ```c
   struct {
       char name[20];
       int age;
   } p;
   ```

   没有结构体类型名，**只能通过变量名 `book` 访问**，不能重复声明更多同类变量

3. `typedef struct {...} Person;`

   typedef 简化结构体名（最常用）

   ```c
   typedef struct {
       char name[20];
       int age;
   } Person;
   
   // 有别名，可以使用 Person 定义变量
   Person p;
   ```

   定义匿名结构体，给它起别名 `Person`

5. **`typedef struct Person {...} Person;`**

   **更常用**的 `typedef struct` 形式

   ```c
   typedef struct Person {
       char name[20];
       int age;
   } Person;
   
   Person p;
   ```

   - 类型名 `struct Person` 可见
   - 别名 `Person` 使用更简洁



# 结构体定义变量

## **`p->val`**、**`(*p).val`**

在 C 语言中，**`p->val`** 和 **`(*p).val`** 的本质是 **完全等价的**，箭头操作符 `->` 是 C 提供的语法糖，可以少写括号

`(*p).val`的括号必须加，`.`的优先级比`*`更高

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode* next;
} ListNode;

int main() {
    ListNode* p = malloc(sizeof(ListNode));    // 内存分配方式定义结构体
    p->val = 10;
    (*p).val = 20;

    printf("%d\n", p->val);  // 输出：20
}
```

- `(*p).val`

  `p` 是指针

  `*p` 是结构体对象

  `(*p).val` 访问成员 `val`



## 结构体内存分配方式

| 写法                           | 类型               | 存储位置 | 生命周期 | 是否需要 free           | 适用场景                                                     | 性能 |
| ------------------------------ | ------------------ | -------- | -------- | ----------------------- | ------------------------------------------------------------ | ---- |
| `ListNode *node = malloc(...)` | **指针**           | **堆**   | 手动管理 | :white_check_mark: 需要 | **链表节点**、动态数据结构                                   | 稍慢 |
| `ListNode node;`               | 结构体**变量**本体 | **栈**   | 自动管理 | :x:**不需要**           | **临时变量**、小对象<br />一旦函数结束，变量 `node` 自动被释放<br />故而**不可作函数返回值**等使用 | 更快 |

```c
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

int main() {
    ListNode dummy;
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
}
```

1. `ListNode* dummy = newNode(0);` 声明**指针**

   ```c
   ListNode* func() {
       ListNode *node = malloc(sizeof(ListNode));
       node->val = 10;
       return node;
   }
   ```

2. `ListNode dummy;` 声明**变量**

   可作为临时变量使用，如链表的`dummy`虚拟头节点，用完就自动删了

   ```c
   ListNode func() {
       ListNode node;
       node.val = 10;       // 可以使用 `.`
       return node;         // OK，按值返回，返回的是 整个结构体拷贝
   }
   
   ListNode p = func();
   // p.val = 10
   ```

   ```c
   ListNode* func() {
       ListNode node;       // ❌ 错误用法！
       node.val = 10;
       return &node;        // ❌ 返回栈内存，函数结束 node 消失
   }
   ```

   