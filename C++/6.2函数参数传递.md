# 函数参数的传递

## 把形参拷贝优化为形参引用（优化版）

实现让传入的值递增1的函数

1. 使用指针，指针的妙用啊

   ```c++
   // 让传入的值递增1
   void increase(int* p) {
   	(*p)++;
   }
   
   int main() {
   	int a = 0;
   
   	for (int i = 0; i < 5; i++) {
   		increase(&a);
   	}
   
   	cout << a << endl;      // 5
   	return 0;
   }
   ```

2. **引用**。不会分配多余的内存，**操作更快**。但是在主函数中，数据被修改逻辑不清晰。

   ```c++
   void increase(int& p) {
   	p++;
   }
   
   int main() {
   	int a = 0;
   
   	for (int i = 0; i < 5; i++) {
   		increase(a);
   	}
   
   	cout << a << endl;      // 5
   	return 0;
   }
   ```

   计算字符串的长度，引用相较于直接传字符串，避免了形参的复制；万一字符串很大很大，这就可以提升很大的效率了（这个函数才能体现出引用的优点）

   ```c++
   // 使用常量引用，避免对数据的修改
   int getStrLength(const string& str) {
       return str.size();
   }
   
   int main() {
   	string str = "ABC";
       
       int len = getStrLength(str);
   
   	cout << len << endl;      // 3
   	return 0;
   }
   ```



## 数组形参

1. 一维数组传递

   ```c++
   // 以下三种声明方式本质上是一样的，形参类型都是 const int*
   void printArray(const int* arr);
   void printArray(const int arr[]);
   void printArray(const int arr[5]);     // 5 写了也没用
   ```

2. 使用 `C` 的方式遍历数组，**数组长度必须传**

   ```c++
   void printArray(const int arr[], int size) {
   	for (int i = 0; i < size; i++) {
   		cout << arr[i] << '\t';
   	}
   	cout << endl;
   }
   ```

3. 传入引用数组， **必须指定数组长度**

   ```c++
   void printArray(const int (&arr)[]);  // ❌
   
   void printArray(const int (& arr)[3]) {
   	for (int num : arr) {
   		cout << num << '\t';
   	}
   	cout << endl;
   }
   ```

   

