# 链表算法

## 1.反转链表算法

使用三个指针：

```lua
prev   当前节点的前一个节点  
curr   当前节点  
next   保存 curr->next 防止丢失
```

```c
#include <stdio.h>
#include <stdlib.h>     // 引入 malloc 函数

typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// 工具函数：创建节点
ListNode* newNode(int val) {
    // 返回的是地址（指针）
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;
    return node;
}

ListNode* reverseList(ListNode* head) {
	/*************************************
	 * prev   当前节点的前一个节点
	 * curr   当前节点
	 * next   保存 curr->next 防止丢失
	 *************************************/
    ListNode *prev = NULL, *curr = head, *next;

    while (curr != NULL) {
        next = curr->next;             // 暂存下一个节点
        curr->next = prev;             // 反转指针
        prev = curr;                   // prev 前进
        curr = next;                   // curr 前进
    }

    return prev; // 反转后的新头
}

int main() {
    // 构造链表：1 → 2 → 3 → 4 → 5
    ListNode* n1 = newNode(1);
    ListNode* n2 = newNode(2);
    ListNode* n3 = newNode(3);
    ListNode* n4 = newNode(4);
    ListNode* n5 = newNode(5);

    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n5;

    ListNode* head = reverseList(n1);
    while (head) {
        printf("%d ", head->val);
        head = head->next;
    }

    return 0;
}

```



## 2.寻找链表中间节点

快慢指针法，快指针一次走两步，慢指针一次走两步，当快指针结束时，慢指针则恰好是中点

- 奇数链表取中间节点，偶数列表取中间靠右的节点

```c
#include <stdio.h>
#include <stdlib.h>     // 引入 malloc 函数

typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

/* 工具函数：创建节点 */
ListNode* newNode(int val) {
    // 返回地址（指针）
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;
    return node;
}

ListNode* middleNode(ListNode* head) {
	if (!head || !head->next) return NULL;

    ListNode *slow = head;
    ListNode *fast = head;

    while (fast != NULL && fast->next != NULL) {
		slow = slow->next;
		fast = fast->next->next;
	}
	
	return slow;
}

int main() {
    // 构造链表：1 → 2 → 3 → 4 → 5
    ListNode* n1 = newNode(1);
    ListNode* n2 = newNode(2);
    ListNode* n3 = newNode(3);
    ListNode* n4 = newNode(4);
    ListNode* n5 = newNode(5);
    ListNode* n6 = newNode(6);

    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n5;
    n5->next = n6;

    ListNode* node = middleNode(n1);
    if (node) {
        printf("中链表间节点的值为：%d\n", node->val);
    } else {
        printf("链表为空\n");
    }


    return 0;
}

```



## 3.环形链表

快慢指针判断环形链表

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// 工具函数：创建节点
ListNode* newNode(int val) {
    // 返回地址（指针）
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;
    return node;
}

// 判断链表是否有环：快慢指针
/* int hasCycle(ListNode *head) {
    if (head == NULL || head->next == NULL) {
        return 0; // 无环
    }

    ListNode *slow = head;
    ListNode *fast = head;

    while (fast != NULL && fast->next != NULL) {   // fast == NULL 链表无环
        slow = slow->next;           // 走一步
        fast = fast->next->next;     // 走两步

        if (slow == fast) {          // 相遇 → 有环
            return 1;
        }
    }

    return 0; // fast 到达空 → 无环
} */

/********************************
 * 判断链表是否有环并且，查找环的起点
 ********************************/
ListNode* detectCycle(ListNode *head) {
    if (!head || !head->next) return NULL;

    ListNode *slow = head;
    ListNode *fast = head;

    /* 第一阶段：判断是否有环，找到相遇点 */
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)  break;  // 相遇
    }

    // 无环
    if (!fast || !fast->next) return NULL;

    /******************************
	 * 第二阶段：找到环的入口
	 * 经过计算，头指针到环起点的距离 = 相遇点到环起点的距离
	 * https://www.bilibili.com/video/BV1gJbnzwEqr?spm_id_from=333.788.videopod.sections&vd_source=5da7dcf8b0e83c07187316079cddc1d6
	 ******************************/
    slow = head;  // 其中一个指针移到头节点

    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }

    return slow;  // slow 或 fast 都行
}

int main() {
    // 构造链表：1 → 2 → 3 → 4 → 5 → 3（环入口为节点 3）
    ListNode* n1 = newNode(1);
    ListNode* n2 = newNode(2);
    ListNode* n3 = newNode(3);
    ListNode* n4 = newNode(4);
    ListNode* n5 = newNode(5);

    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n5;
    n5->next = n3;  // 环的入口

    ListNode* entry = detectCycle(n1);
    if (entry) {
        printf("环的入口节点值为: %d\n", entry->val);
    } else {
        printf("链表无环\n");
    }

    return 0;
}

```

寻找数组中的重复数字

```c
#include <stdio.h>

int findDuplicate(int* nums, int numsSize){
	int slow=0, fast=0;
	// 快慢指针找到环形链表
	do {
		slow = nums[slow];
		fast = nums[nums[fast]];
	} while (slow != fast);
	
	printf("slow = %d, fast = %d\n", slow, fast);   // 6, 6
	
	// 找到环形链表的起始
	slow = 0;
	while (slow != fast) {
		slow = nums[slow];
		fast = nums[fast];
	}
	return slow;     // 1
}

/******************
 * 找到(1-n)的数组的唯一一个重复的数
 * 1, 2, 3, 4, 5, 6, 1, 7, 8, 9 值与数组下标可以形成环
 ****************/
int main() {
	int nums[10] = {1, 2, 3, 4, 5, 6, 1, 7, 8, 9};
	int result = findDuplicate(nums, 10);
	printf("%d", result);
	return 0;
}

```

英雄的双指针算法`https://www.bilibili.com/video/BV1HG411C7ZM/?spm_id_from=333.1387.upload.video_card.click&vd_source=5da7dcf8b0e83c07187316079cddc1d6`



## 4.删除链表的**倒数**第n个节点

快慢指针法

1. 指针先走N步数
2. 快慢指针同时前进
3. 当快指针的下一个节点是NULL（末尾节点）时，慢指针指向的下下个节点就是需要删除的节点

```c
ListNode* removeNthFromEnd(ListNode* head, int n) {
    /* 1. 创建虚拟头节点 */
    ListNode* dummy = newNode(0);
    dummy->next = head;

    ListNode* fast = dummy;
    ListNode* slow = dummy;

    /* 2. fast 先走 n 步 */
    int i;
    for (i = 0; i < n; i++) {
        if (fast->next == NULL) return head; // n 超范围
        fast = fast->next;
    }

    /* 3. fast 和 slow 一起走，直到 fast 到尾部 */
    while (fast->next != NULL) {
        fast = fast->next;
        slow = slow->next;
    }

    /* 4. slow->next 就是要删除的节点 */
    ListNode* toDelete = slow->next;
    slow->next = slow->next->next;
    free(toDelete);

    /* 5. 返回新链表头 */
    ListNode* newHead = dummy->next;
    free(dummy);
    return newHead;
}
```



## 5.合并两个有序链表

使用**三个指针**：指针1指向 list1 的头节点，指针2指向 list2 的头节点，指针`tail`标识当前对比到哪一个节点

1. 迭代法

   ```c
   #include <stdio.h>
   #include <stdlib.h>     // 引入 malloc 函数
   
   typedef struct ListNode {
       int val;
       struct ListNode *next;
   } ListNode;
   
   // 工具函数：创建节点
   ListNode* newNode(int val) {
       ListNode* node = (ListNode*)malloc(sizeof(ListNode));
       node->val = val;
       node->next = NULL;
       return node;
   }
   
   // 主函数
   ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
   	ListNode dummy;       // 虚拟头结点
       dummy.next = NULL;
       ListNode* tail = &dummy;
   
       while (l1 != NULL && l2 != NULL) {
           if (l1->val < l2->val) {
               tail->next = l1;
               l1 = l1->next;
           } else {
               tail->next = l2;
               l2 = l2->next;
           }
           tail = tail->next;
       }
   
       /* 把剩余部分接上（不会冲突） */
       if (l1 != NULL) tail->next = l1;
       else tail->next = l2;
   
       return dummy.next;
   }
   
   int main() {
       // 构造链表：1 → 2 → 3 → 4 → 5
       ListNode* n1 = newNode(1);
       ListNode* n2 = newNode(2);
       ListNode* n3 = newNode(3);
       ListNode* n4 = newNode(4);
       ListNode* n5 = newNode(5);
       ListNode* n6 = newNode(6);
       ListNode* n7 = newNode(7);
       ListNode* n8 = newNode(8);
       ListNode* n9 = newNode(9);
   
       n1->next = n3;
       n3->next = n5;
       
       n2->next = n4;
       n4->next = n6;
       n6->next = n7;
       n7->next = n8;
       n8->next = n9;
   
   	ListNode* firstHead = n1;
   	ListNode* secondHead = n2;
   	while (firstHead) {
   		printf("%d ", firstHead->val);
   		firstHead = firstHead->next;
   	}
   	printf("\n");
   	while (secondHead) {
   		printf("%d ", secondHead->val);
   		secondHead = secondHead->next;
   	}
   	printf("\n");
   	
   	ListNode* head = mergeTwoLists(n1, n2);
   	while (head) {
           printf("%d ", head->val);
           head = head->next;
       }
   
       return 0;
   }
   
   ```

2. 递归

   ```c
   ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
       if (l1 == NULL) return l2;
       if (l2 == NULL) return l1;
   
       if (l1->val < l2->val) {
           l1->next = mergeTwoLists(l1->next, l2);
           return l1;
       } else {
           l2->next = mergeTwoLists(l1, l2->next);
           return l2;
       }
   }
   ```



## 6.寻找两个链表的交点

```makefile
A: 1 → 2 → 3
               ↘
                7 → 8 → 9
               ↗
B:       4 → 5
```

1. 用两个指针 `p1`、`p2` 分别从 `headA`、`headB` 出发
2. 走到尾巴后，切换到**对方链表**（A->B，B->A）继续走
3. 如果有交点，最终会在交点相遇
4. 如果没交点，两者会同时变成 `NULL`

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

ListNode* newNode(int val) {
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;
    return node;
}

// 寻找交点函数
ListNode* getIntersectionNode(ListNode* headA, ListNode* headB) {
    if (headA == NULL || headB == NULL) return NULL;

    ListNode* p1 = headA;
    ListNode* p2 = headB;

    while (p1 != p2) {
        p1 = (p1 == NULL) ? headB : p1->next;
        p2 = (p2 == NULL) ? headA : p2->next;
    }

    return p1;  // 可能是交点，也可能是 NULL
}

int main() {
    // 构造链表：1 → 2 → 3 → 4 → 5
    ListNode* n1 = newNode(1);
    ListNode* n2 = newNode(2);
    ListNode* n3 = newNode(3);
    ListNode* n4 = newNode(4);
    ListNode* n5 = newNode(5);
    ListNode* n6 = newNode(6);
    ListNode* n7 = newNode(7);
    ListNode* n8 = newNode(8);

    n1->next = n2;
    n2->next = n3;
    n3->next = n6;

    n4->next = n5;
    n5->next = n6;

    n6->next = n7;
    n7->next = n8;

	ListNode* firstHead = n1;
	ListNode* secondHead = n4;
	while (firstHead) {
		printf("%d ", firstHead->val);
		firstHead = firstHead->next;
	}
	printf("\n");
	while (secondHead) {
		printf("%d ", secondHead->val);
		secondHead = secondHead->next;
	}
	printf("\n");

	ListNode* node = getIntersectionNode(n1, n4);
	if (node) {
        printf("两个链表的交点是：%d", node->val);
    } else {
    	printf("两个链表没有交点");
	}

    return 0;
}

```



## 7.回文链表

判断一个链表是不是回文链表

1. 找到链表的中点
2. 将中点往后的链表反转
3. 对比两个链表是否全等即可



## 8.排序链表(Sort List)

对一个无序链表进行排序

- 归并排序

  1. 找中点，拆成两个链表
  2. 按顺序合并这两个链表

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  
  // 链表节点定义
  typedef struct ListNode {
      int val;
      struct ListNode* next;
  } ListNode;
  
  // 创建新节点
  ListNode* newNode(int val) {
      ListNode* node = (ListNode*)malloc(sizeof(ListNode));
      node->val = val;
      node->next = NULL;
      return node;
  }
  
  // 合并两个有序链表
  ListNode* merge(ListNode* l1, ListNode* l2) {
      ListNode dummy;
      ListNode* tail = &dummy;
      dummy.next = NULL;
  
      while (l1 && l2) {
          if (l1->val < l2->val) {
              tail->next = l1;
              l1 = l1->next;
          } else {
              tail->next = l2;
              l2 = l2->next;
          }
          tail = tail->next;
      }
      tail->next = (l1) ? l1 : l2;
      return dummy.next;
  }
  
  // 找链表中点并拆分
  ListNode* getMid(ListNode* head) {
      ListNode* slow = head;
      ListNode* fast = head->next; // 注意 fast 从 head->next 开始避免死循环
  
      while (fast && fast->next) {
          slow = slow->next;
          fast = fast->next->next;
      }
  
      ListNode* mid = slow->next;
      slow->next = NULL; // 拆分
      return mid;
  }
  
  // 归并排序链表
  ListNode* mergeSort(ListNode* head) {
      if (!head || !head->next) return head;
  
      ListNode* mid = getMid(head);
      ListNode* left = mergeSort(head);
      ListNode* right = mergeSort(mid);
  
      return merge(left, right);
  }
  
  // 打印链表
  void printList(ListNode* head) {
      while (head) {
          printf("%d ", head->val);
          head = head->next;
      }
      printf("\n");
  }
  
  // 测试
  int main() {
      int arr[] = {4, 2, 1, 3, 5};
      int n = sizeof(arr)/sizeof(arr[0]);
  
      ListNode* head = NULL;
      ListNode* tail = NULL;
      int i;
      for (i = 0; i < n; i++) {
          ListNode* node = newNode(arr[i]);
          if (!head) {
              head = node;
              tail = node;
          } else {
              tail->next = node;
              tail = node;
          }
      }
  
      printf("排序前: ");
      printList(head);
  
      head = mergeSort(head);
  
      printf("排序后: ");
      printList(head);
  
      return 0;
  }
  
  ```

  
