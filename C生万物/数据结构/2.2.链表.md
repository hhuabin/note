# 链表算法

## 1.反转链表算法

使用三个指针：

```lua
prev   当前节点的前一个节点  
curr   当前节点  
next   保存 curr->next 防止丢失
```

```c
#include <stdio.h>
#include <stdlib.h>     // 引入 malloc 函数

typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// 工具函数：创建节点
ListNode* newNode(int val) {
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;
    return node;
}

struct ListNode* reverseList(struct ListNode* head) {
	/*************************************
	 * prev   当前节点的前一个节点
	 * curr   当前节点
	 * next   保存 curr->next 防止丢失
	 *************************************/
    ListNode *prev = NULL, *curr = head, *next;

    while (curr != NULL) {
        next = curr->next;             // 暂存下一个节点
        curr->next = prev;             // 反转指针
        prev = curr;                   // prev 前进
        curr = next;                   // curr 前进
    }

    return prev; // 反转后的新头
}

int main() {
    // 构造链表：1 → 2 → 3 → 4 → 5
    ListNode* n1 = newNode(1);
    ListNode* n2 = newNode(2);
    ListNode* n3 = newNode(3);
    ListNode* n4 = newNode(4);
    ListNode* n5 = newNode(5);

    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n5;

    ListNode* head = reverseList(n1);
    while (head) {
        printf("%d ", head->val);
        head = head->next;
    }

    return 0;
}

```



## 2.寻找链表中间节点



## 3.环形链表

快慢指针判断环形链表

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// 工具函数：创建节点
ListNode* newNode(int val) {
    ListNode* node = (ListNode*)malloc(sizeof(ListNode));
    node->val = val;
    node->next = NULL;
    return node;
}

// 判断链表是否有环：快慢指针
/* int hasCycle(struct ListNode *head) {
    if (head == NULL || head->next == NULL) {
        return 0; // 无环
    }

    ListNode *slow = head;
    ListNode *fast = head;

    while (fast != NULL && fast->next != NULL) {   // fast == NULL 链表无环
        slow = slow->next;           // 走一步
        fast = fast->next->next;     // 走两步

        if (slow == fast) {          // 相遇 → 有环
            return 1;
        }
    }

    return 0; // fast 到达空 → 无环
} */

/********************************
 * 判断链表是否有环并且，查找环的起点
 ********************************/
struct ListNode* detectCycle(struct ListNode *head) {
    if (!head || !head->next) return NULL;

    ListNode *slow = head;
    ListNode *fast = head;

    /* 第一阶段：判断是否有环，找到相遇点 */
    while (fast && fast->next) {
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast)  break;  // 相遇
    }

    // 无环
    if (!fast || !fast->next) return NULL;

    /******************************
	 * 第二阶段：找到环的入口
	 * 经过计算，头指针到环起点的距离 = 相遇点到环起点的距离
	 * https://www.bilibili.com/video/BV1gJbnzwEqr?spm_id_from=333.788.videopod.sections&vd_source=5da7dcf8b0e83c07187316079cddc1d6
	 ******************************/
    slow = head;  // 其中一个指针移到头节点

    while (slow != fast) {
        slow = slow->next;
        fast = fast->next;
    }

    return slow;  // slow 或 fast 都行
}

int main() {
    // 构造链表：1 → 2 → 3 → 4 → 5 → 3（环入口为节点 3）
    ListNode* n1 = newNode(1);
    ListNode* n2 = newNode(2);
    ListNode* n3 = newNode(3);
    ListNode* n4 = newNode(4);
    ListNode* n5 = newNode(5);

    n1->next = n2;
    n2->next = n3;
    n3->next = n4;
    n4->next = n5;
    n5->next = n3;  // 环的入口

    ListNode* entry = detectCycle(n1);
    if (entry) {
        printf("环的入口节点值为: %d\n", entry->val);
    } else {
        printf("链表无环\n");
    }

    return 0;
}

```

寻找数组中的重复数字

```c
#include <stdio.h>

int findDuplicate(int* nums, int numsSize){
	int slow=0, fast=0;
	// 快慢指针找到环形链表
	do {
		slow = nums[slow];
		fast = nums[nums[fast]];
	} while (slow != fast);
	
	printf("slow = %d, fast = %d\n", slow, fast);   // 6, 6
	
	// 找到环形链表的起始
	slow = 0;
	while (slow != fast) {
		slow = nums[slow];
		fast = nums[fast];
	}
	return slow;     // 1
}

/******************
 * 找到(1-n)的数组的唯一一个重复的数
 * 1, 2, 3, 4, 5, 6, 1, 7, 8, 9 值与数组下标可以形成环
 ****************/
int main() {
	int nums[10] = {1, 2, 3, 4, 5, 6, 1, 7, 8, 9};
	int result = findDuplicate(nums, 10);
	printf("%d", result);
	return 0;
}
```

英雄的双指针算法`https://www.bilibili.com/video/BV1HG411C7ZM/?spm_id_from=333.1387.upload.video_card.click&vd_source=5da7dcf8b0e83c07187316079cddc1d6`