找出**==状态转移方程==**是重中之重

# 斐波那契数列

1. 简单递推

   ```c
   #include <stdio.h>
   
   int fib(int n) {
       if (n <= 1) return n;
       return fib(n - 1) + fib(n - 2);
   }
   
   int main() {
       int n;
       scanf("%d", &n);
       printf("%lld\n", fib(n));
       return 0;
   }
   ```

   - 对每个 `n`，都会递归计算 `fib(n-1)` 和 `fib(n-2)`，递归树呈 **指数级增长**
   - 时间复杂度：**O(2ⁿ)**；空间复杂度：递归栈 **O(n)**

2. ==**使用数组记忆（空间），提升速度（换时间）**==，这是最具参考性的解决思路 `fib[i] = fib[i - 1] + fib[i - 2];`，在此基础上，能优化再优化

   ```c
   int fib(int n) {
   	if (n <= 1) return n;
   
   	long long fib[n + 1];
   
       fib[0] = 0;
       fib[1] = 1;
   
   	int i;
       for (i = 2; i <= n; i++) {
           fib[i] = fib[i - 1] + fib[i - 2];      // 状态转移方程
       }
   
       return fib[n];
   }
   ```

   时间复杂度 **O(n)**，空间复杂度 **O(n)**

3. 最终版，只需要记忆相加后的数字即可

   ```c
   int fib(int n) {
   	if (n <= 1) return n;
   
       long long a = 0LL, b = 1LL, c;
   
   	int i;
       for (i = 2; i <= n; i++) {
           c = a + b;
           a = b;
           b = c;
       }
       
       return c;
   }
   ```

   时间复杂度 **O(n)**，空间复杂度 **O(1)**



# 递推衍生题

利用递推还可以解决很多类似的问题

1. **爬楼梯的最少成本**

   数组的每个下标作为一个阶梯，第 `i` 个阶梯对应着一个非负数的体力花费值 `cost[i]`(下标从0开始)。
   每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。
   请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为0或1的元素作为初始阶梯。

   示例：

   ```c
   输入: cost = [10，15，20]
   输出: 15
   解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶,共花费15
   ```

   ```c
   输入: cost = [1，100，1，1，1，100，1，1，100，1]
   输出: 6
   解释: 最低花费方式是从 cost[0] 开始，逐个经过那些1，跳过 cost[3]，一共花费6。
   ```

   **状态转移方程 `f[i] = min(f[i-1] + cost[i-1], f[i-2] + cost[i-2])`**

   ```c
   #include <stdio.h>
   
   int minCostClimbingStairs(int* cost, int n) {
       if (n == 0) return 0;
       if (n == 1) return cost[0];
   
       int f[n + 1]; // f[i] 表示到达第 i 阶的最小花费
       f[0] = 0;     // 到达楼底第0阶不花费
       f[1] = 0;     // 可以从第0阶或第1阶开始，所以f[1]=0
   
   	int i;
       for (i = 2; i <= n; i++) {
   		// 由于C没有对应的 min() 函数，故使用三目运算符取最小值
           f[i] = (f[i - 1] + cost[i - 1] < f[i - 2] + cost[i - 2])
   				? f[i - 1] + cost[i - 1]
   				: f[i - 2] + cost[i - 2];
       }
   
       return f[n]; // 到达楼顶的最小花费
   }
   
   int main() {
       int cost[] = {1, 100, 1, 1, 1, 100, 1, 1, 100, 1};
       int n = sizeof(cost) / sizeof(cost[0]);   // 取数组长度
       int result = minCostClimbingStairs(cost, n);
       printf("%d\n", result);
       return 0;
   }
   ```

   
