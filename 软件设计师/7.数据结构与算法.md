<img title="avatat" src="./image/7-1.jpg" alt="" width="600">

# 数据结构与算法

>去看C语言的:dog: -> [查找算法](../C生万物/查找算法.md "数据结构")
>
>去看C语言的:dog: -> [排序算法](../C生万物/排序算法.md "数据结构")



## 算法策略

| 算法名称   | 关键点                                               | 特征                                                         | 典型问题                             | 时间复杂度                                                   |
| ---------- | ---------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------ | ------------------------------------------------------------ |
| 分治法     | 递归技术                                             | 把一个问题拆分成多个小规模的相同子问题，一般可用**递归解决**。 | 归并排序、**快速排序**、二分搜索     | 复杂度可能因具体实现和问题而异。<br />如：归并排序是*O*(*n*log*n*)，<br />快速排序是*O*(*n*log*n*) / O(n2) |
| 贪心法     | 一般用于求满意解，<br />特殊情况可求最优解(部分背包) | **局部最优**，但整体不见得最优。每步有明确的、既定的策略。   | 背包问题(如装箱)、多机调度找零钱问题 | 同上                                                         |
| 动态规划法 | 最优子结构和递归式                                   | 划分子问题(**最优子结构**)，使用数组存储子问题结果，<br />利用查询子问题结果构造最终问题结果。 | **斐波那契**、 LCS最长公共子序列     | 同上                                                         |
| 回溯法     | 探索和回退                                           | 系统地搜索一个问题的所有解或任一解。有试探和回退的过程。     | 数独求解                             | 同上                                                         |



### 分治法

- **核心思想**：将问题分解为若干子问题，递归解决子问题后合并结果。
- **典型应用**：归并排序、快速排序、二分查找、大整数乘法。
- **特点**：
  - 子问题需独立且与原问题结构相同。
  - 通常用递归实现，需注意递归深度和效率。



### 贪心法

- **核心思想**：每一步选择当前局部最优解，希望最终达到全局最优。
- **典型应用**：霍夫曼编码、Dijkstra算法、最小生成树（Prim/Kruskal）。
- **特点**：
  - 高效但不一定能得到全局最优解（需问题具备贪心选择性质）。



### 动态规划法

- **核心思想**：通过保存子问题的解避免重复计算，适用于有重叠子问题和最优子结构的问题。
- **典型应用**：背包问题、最短路径（Floyd-Warshall）、斐波那契数列优化。
- **实现方式**：
  - **自顶向下**：递归 + 记忆化（Memoization）。
  - **自底向上**：迭代填表（Tabulation）。

[英雄的动态规划](https://www.bilibili.com/video/BV1XR4y1j7Lo/?spm_id_from=333.337.search-card.all.click&vd_source=5da7dcf8b0e83c07187316079cddc1d6)

1. 设计状态
2. 写出状态转移方程
3. 设定初始状态
4. 执行状态转移
5. 返回最终的解

记住每个数字相加的值，如：**斐波那契数列**

```c
#include <stdio.h>

int fibonacci(int n) {
    if (n <= 1) return n;
    
    int dp[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    
    return dp[n];
}

int main() {
    int n;
    printf("输入 n：");
    scanf("%d", &n);
    printf("Fibonacci(%d) = %d\n", n, fibonacci(n));
    return 0;
}
```



### 回溯法

- **核心思想**：通过递归尝试所有可能的解，遇到无效解时回退（剪枝）。
- **典型应用**：N皇后问题、数独、全排列、组合问题。
- **特点**：
  - 本质是暴力搜索的优化，通过剪枝减少计算量。
